import pandas as pd
import networkx as nx
import numpy as np
import warnings
import matplotlib
from sklearn.model_selection import train_test_split

threshold = 0.46
df = pd.read_csv('my_filtered_dataset.csv')
del df['ID']  # ID is not an explanatory variable, so we drop that.
del df['date']
del df['index']
# most_pred_features = ['Price','grade','sqft_living','bathrooms','sqft_living15', 'sqft_above', 'dist_to_center']
# df = df[most_pred_features]
print('Missing values? ', df.isnull().values.any())
# There are no missing values

# Split into training and test set
# training data = df, because we only want to use training data to build features!
df, tedata = train_test_split(df, test_size=0.2, random_state=42)
print("Length of training dataset: ", len(df))

# Definieer de kolommen die we als features beschouwen en de target
# De target staat vanvoor, alle andere kolommen gebruiken we als features
feature_cols = list(df.columns[1:])
print('Dit zijn onze features: ' + str(feature_cols))
target = ['Price']
print('Target: ' + str(target))

# Load the distance matrix that we stored
dist_matrix = np.load('my_filtered_distances.npy')


def build_graph_distance(features, dist_threshold):
    print('Building graph...')
    # create an empty graph using networkx
    G = nx.Graph()
    # add nodes to the graph
    for i in features.iterrows():
        node_features = pd.Series.to_dict(i[1])  # convert the row to a dictionary of features
        # id: we nemen gewoon de index in de dataframe
        id_node = i[0]
        # features: we selecteren uit de rij in de dataframe enkel de kolommen die we als features beschouwen
        x_node = i[1][feature_cols].values
        # target: we selecteren opnieuw uit de huidige rij enkel de target, nl de prijs
        y_node = i[1][target].values
        # print(y_node)
        G.add_node(id_node, x=x_node, y=y_node)  # add the node to the graph with its features

    # print the number of nodes and their features
    # print("Number of nodes:", G.number_of_nodes())
    # for node in G.nodes():
    # print(f"Node {node} features:", G.nodes[node])

    # calculate the distance between each pair of houses and add edges to the graph with the distance as the edge weight
    for i, node1 in G.nodes(data=True):
        for j, node2 in G.nodes(data=True):
            if i < j:
                dist = dist_matrix[i, j]
                if dist <= dist_threshold:  # Enkel edge indien de huizen op minder dan ...km van elkaar liggen
                    G.add_edge(i, j, weight=1 / dist)
    return G


G = build_graph_distance(df, threshold)

personalization = {node: df['Price'][node] for node in G.nodes()}
pr = nx.pagerank(G, personalization=personalization)
for node, score in pr.items():
    print(f"Node {node}: PageRank score = {score:.4f}")
